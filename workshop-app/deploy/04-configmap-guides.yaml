apiVersion: v1
kind: ConfigMap
metadata:
  name: workshop-guides
  namespace: workshop-gitops
  labels:
    app: gitops-workshop
data:
  01-DEMO1-MANUAL-CHANGE.md: |
    # Demo 1: Manual Change Detection and Drift Correction
    
    ## Overview
    This demo demonstrates how ArgoCD detects manual changes made directly to OpenShift resources and corrects the configuration drift by reverting to the state defined in Git through manual sync operations. The demo is automated through Ansible playbooks but includes manual step-by-step instructions for educational purposes.
    
    ## Prerequisites
    - OpenShift GitOps Workshop installed and configured
    - GUID environment variable set (`export GUID=user01`)
    - Workshop GitOps VMs development environment deployed
    - Access to OpenShift cluster with `oc` CLI and cluster admin privileges
    
    ## What the Demo Does
    
    1. **Initial Status Check**: Verifies the VM exists and is in the correct initial state
    2. **Manual Change**: Patches the VM to change `runStrategy` from `Always` to `Halted`
    3. **Drift Detection**: Monitors ArgoCD application for drift detection
    4. **Manual Sync Verification**: Confirms ArgoCD corrects the drift through manual sync
    5. **Final Validation**: Ensures the VM returns to the desired Git-defined state
    
    ## Environment Details
    - **GUID**: Dynamic based on environment variable
    - **Namespace**: `workshop-gitops-vms-dev`
    - **VM Name**: `dev-vm-web-01`
    - **ArgoCD Application**: `workshop-gitops-vms-dev`
    - **Git Run Strategy**: `Always` (VM should be running)
    - **Manual Change**: Set `runStrategy` to `Halted` (stop the VM)
    
    ## Step-by-Step Manual Instructions
    
    ### Step 1: Check Current VM State and Application Status
    
    1. Check the ArgoCD application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}' ; echo
    ```
    
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.health.status}' ; echo
    ```
    
    2. Verify the VM exists and is running:
    ```bash
    oc get vm dev-vm-web-01 -n workshop-gitops-vms-dev
    ```
    
    ```bash
    oc get vmi dev-vm-web-01 -n workshop-gitops-vms-dev
    ```
    
    3. Check the current runStrategy (should be "Always"):
    ```bash
    oc get vm dev-vm-web-01 -n workshop-gitops-vms-dev -o jsonpath='{.spec.runStrategy}' ; echo
    ```
    
    **Expected Result**: VM should exist and be running with `runStrategy: Always`
    
    ### Step 2: Make Manual Change to Stop the VM
    
    1. Apply a manual change to halt the VM:
    ```bash
    oc patch vm dev-vm-web-01 -n workshop-gitops-vms-dev --type merge -p '{"spec":{"runStrategy":"Halted"}}'
    ```
    
    2. Verify the change was applied:
    ```bash
    oc get vm dev-vm-web-01 -n workshop-gitops-vms-dev -o jsonpath='{.spec.runStrategy}' ; echo
    ```
    
    **Expected Result**: `runStrategy` should now be "Halted"
    
    ### Step 3: Wait for VM to Shut Down
    
    1. Monitor the VirtualMachineInstance deletion:
    ```bash
    oc get vmi dev-vm-web-01 -n workshop-gitops-vms-dev
    ```
    
    2. Wait for the VMI to be completely removed:
    ```bash
    oc get vmi dev-vm-web-01 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: The VirtualMachineInstance should be deleted, confirming the VM has stopped
    
    ### Step 4: Force ArgoCD to Detect the Drift
    
    1. Force application refresh to detect changes:
    ```bash
    oc patch applications workshop-gitops-vms-dev -n openshift-gitops --type merge -p '{"operation":{"initiatedBy":{"username":"admin"},"sync":{"revision":"HEAD"}}}'
    ```
    
    2. Check application status repeatedly until drift is detected:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}' ; echo
    ```
    
    **Expected Result**: Sync status should return to "Synced"
    
    ### Step 5: Verify Configuration Restoration
    
    1. Check that the runStrategy has been reverted:
    ```bash
    oc get vm dev-vm-web-01 -n workshop-gitops-vms-dev -o jsonpath='{.spec.runStrategy}' ; echo
    ```
    
    2. Wait for the VM to start again:
    ```bash
    watch oc get vm dev-vm-web-01 -n workshop-gitops-vms-dev -o jsonpath='{.status.printableStatus}'
    ```
    
    3. Verify the VirtualMachineInstance is running:
    ```bash
    oc get vmi dev-vm-web-01 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: 
    - `runStrategy` should be back to "Always"
    - VM status should be "Running"
    - VirtualMachineInstance should exist and be ready
    
    ### Step 6: Final Verification
    
    1. Check final application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    2. List all VMs in the development environment:
    ```bash
    oc get vm -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: Application should be "Synced" and "Healthy"
    
    ## Summary of What Was Demonstrated
    
    ✓ **Manual Change**: Made a direct change to VM configuration (stopped the VM)  
    ✓ **Drift Detection**: ArgoCD detected the configuration drift (OutOfSync status)  
    ✓ **Correction**: ArgoCD reverted the change  
    ✓ **State Restoration**: VM was restarted with the correct Git-defined configuration  
    ✓ **GitOps Enforcement**: Demonstrated that Git is the single source of truth  
    
    ## Key Learning Points
    
    - **Configuration Drift**: Manual changes to resources are detected by ArgoCD
    - **Manual Correction**: GitOps corrects unauthorized changes through manual sync operations
    - **Audit Trail**: All changes and corrections are logged in ArgoCD
    - **Consistency**: Git repository remains the authoritative source of configuration
    - **Operational Safety**: Prevents configuration drift in production environments

  02-DEMO2-VM-RECOVERY.md: |
    # Demo 2: VM Recovery from Data Loss
    
    ## Overview
    This demo demonstrates how GitOps can recover from complete system-level data loss scenarios. By forcing an rm -rf / on the VM, we simulate catastrophic data corruption or accidental mass deletion, then show how ArgoCD recreates the entire VM infrastructure from Git definitions through manual sync operations. The demo is automated through Ansible playbooks but includes manual step-by-step instructions for educational purposes.
    
    ## Prerequisites
    - OpenShift GitOps Workshop installed and configured
    - GUID environment variable set (`export GUID=user01`)
    - Workshop GitOps VMs development environment deployed
    - Access to OpenShift cluster with `oc` CLI and cluster admin privileges
    
    ## What the Demo Does
    
    1. **Initial Status Check**: Verifies the VM and associated resources exist
    2. **Documentation**: Records current VM configuration before deletion
    3. **Break the lab**: Executes `sudo rm -rf /*`
    4. **Complete Deletion**: Removes VM, DataVolume, and associated resources (simulating data loss)
    5. **Verification**: Confirms all resources are completely removed
    6. **Recovery Monitoring**: Watches ArgoCD detect missing resources and trigger recovery
    7. **Validation**: Verifies complete VM recreation with original configuration
    8. **Service Testing**: Confirms the recovered VM is fully functional
    
    ## Environment Details
    - **GUID**: Dynamic based on environment variable
    - **Namespace**: `workshop-gitops-vms-dev`
    - **VM Name**: `dev-vm-web-02`
    - **ArgoCD Application**: `workshop-gitops-vms-dev`
    - **Scenario**: Complete VM and storage deletion (simulating data corruption)
    
    ## Step-by-Step Manual Instructions
    
    ### Step 1: Check Current VM State and Application Status
    
    1. Check the ArgoCD application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    2. Verify the VM exists and its current state:
    ```bash
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    3. Check associated DataVolume:
    ```bash
    oc get dv -n workshop-gitops-vms-dev | grep vm-web-02
    ```
    
    4. Check VM pod if running:
    ```bash
    oc get pods -n workshop-gitops-vms-dev | grep dev-vm-web-02
    ```
    
    **Expected Result**: VM should exist and be properly configured with associated storage
    
    ### Step 2: Simulate Data Corruption Scenario
    
    1. Access the VM over SSH and remove /*:
    ```bash
    virtctl ssh cloud-user@dev-vm-web-02 -n workshop-gitops-vms-dev -c "sudo rm -rf /*"
    ```
    
    2. Stop de VM
    ```bash
    virtctl stop dev-vm-web-02 -n workshop-gitops-vms-dev --force --grace-period 0
    ```
    
    3. Delete the VM:
    ```bash
    oc delete vm dev-vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    4. Verify VM deletion:
    ```bash
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: VM should be deleted (command should return "not found")
    
    ### Step 3: Delete Persistent Storage
    
    1. Wait a moment for VM deletion to propagate:
    ```bash
    sleep 5
    ```
    
    2. Check if DataVolume still exists:
    ```bash
    oc get dv vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    3. Delete the DataVolume to simulate complete data loss:
    ```bash
    oc delete dv vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    4. Verify DataVolume deletion:
    ```bash
    oc get dv vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: Both VM and DataVolume should be completely removed
    
    ### Step 4: Wait for ArgoCD to Detect Missing Resources
    
    1. Monitor application sync status until drift is detected:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}' ; echo
    ```
    
    2. You can force a refresh if needed:
    ```bash
    oc annotate applications workshop-gitops-vms-dev -n openshift-gitops argocd.argoproj.io/refresh="$(date)" --overwrite
    ```
    
    **Expected Result**: Application sync status should change to "OutOfSync"
    
    ### Step 5: Trigger ArgoCD Sync for Recovery
    
    1. Trigger manual sync to recreate the missing resources:
    ```bash
    oc patch applications workshop-gitops-vms-dev -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}' &>/dev/null
    ```
    
    2. Monitor the sync process:
    ```bash
    watch oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}'
    ```
    
    **Expected Result**: ArgoCD should start recreating the missing VM
    
    ### Step 6: Monitor VM Recreation
    
    1. Watch for VM recreation:
    ```bash
    # Run this command repeatedly until VM appears
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    2. Monitor VM status during creation:
    ```bash
    watch oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev -o custom-columns="NAME:.metadata.name,STATUS:.status.printableStatus"
    ```
    
    3. Check for DataVolume recreation:
    ```bash
    oc get dv -n workshop-gitops-vms-dev | grep vm-web-02
    ```
    
    **Expected Result**: VM should be recreated and start initializing
    
    ### Step 7: Wait for Application Sync Completion
    
    1. Monitor until application returns to Synced state:
    ```bash
    watch oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}'
    ```
    
    2. Check application health:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.health.status}' ; echo
    ```
    
    **Expected Result**: Application should return to "Synced" and "Healthy" status
    
    ### Step 8: Verify Complete Recovery
    
    1. Confirm VM exists and is properly configured:
    ```bash
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev -o custom-columns="NAME:.metadata.name,STATUS:.status.printableStatus,MEMORY:.spec.template.spec.domain.resources.requests.memory"
    ```
    
    2. Check DataVolume status:
    ```bash
    oc get dv -n workshop-gitops-vms-dev | grep vm-web-02
    ```
    
    3. Verify VM configuration matches Git definition:
    ```bash
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev -o jsonpath='{.spec.runStrategy}' ; echo
    ```
    ```bash
    oc get vm dev-vm-web-02 -n workshop-gitops-vms-dev -o jsonpath='{.spec.template.spec.domain.resources.requests.memory}' ; echo
    ```
    
    4. Check if VM is running (may take time to start):
    ```bash
    oc get vmi dev-vm-web-02 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: 
    - VM should be recreated with correct configuration
    - DataVolume should be recreated
    - VM should eventually start running
    
    ### Step 9: Final Verification
    
    1. List all VMs in the development environment:
    ```bash
    oc get vm -n workshop-gitops-vms-dev
    ```
    
    2. Check final application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    3. Verify the recreated VM has fresh storage:
    ```bash
    oc describe dv vm-web-02 -n workshop-gitops-vms-dev | grep -A 5 "Source:"
    ```
    
    **Expected Result**: All resources should be recreated and application should be healthy
    
    ## Summary of What Was Demonstrated
    
    ✓ **Complete Data Loss**: Simulated catastrophic failure by deleting VM and storage  
    ✓ **Detection**: ArgoCD detected missing critical resources (OutOfSync status)  
    ✓ **Manual Recovery**: ArgoCD recreated all missing resources after manual sync  
    ✓ **Fresh Storage**: New DataVolume created with clean base image  
    ✓ **Full Restoration**: Complete infrastructure recovered from Git definitions  
    ✓ **Disaster Recovery**: Demonstrated GitOps-based disaster recovery capabilities  
    
    ## Key Learning Points
    
    - **Disaster Recovery**: GitOps provides disaster recovery capabilities through manual sync
    - **Infrastructure as Code**: VM definitions in Git enable complete recreation
    - **No Data Loss Prevention**: While data is lost, infrastructure is quickly restored
    - **Consistency**: Recovered VM matches exact Git specification
    - **Manual Control**: Sync operations require explicit manual trigger for controlled recovery
    - **Audit Trail**: Recovery process is logged and traceable
    
    ## Use Cases
    
    This pattern is valuable for:
    - **Disaster Recovery**: Recovering from hardware failures
    - **Environment Refresh**: Creating clean development environments
    - **Compliance**: Ensuring infrastructure matches approved configurations
    - **Testing**: Validating complete deployment processes

  03-DEMO3-ADD-DEVELOPMENT-VM.md: |
    # Demo 3: Adding New Development VM via Git Change
    
    ## Overview
    This demo demonstrates how to add new Virtual Machines to the environment using GitOps workflow. By adding a new VM definition to Git and updating the kustomization, ArgoCD deploys the new infrastructure through manual sync operations without direct OpenShift intervention. The demo is automated through Ansible playbooks but includes manual step-by-step instructions for educational purposes.
    
    ## Prerequisites
    - OpenShift GitOps Workshop installed and configured
    - GUID environment variable set (`export GUID=user01`)
    - Workshop GitOps VMs development environment deployed
    - Access to Git repository: `OpenShift-Virtualization-GitOps-Apps`
    - Git configured for commits and push access to the repository
    
    ## What the Demo Does
    
    1. **Initial Status Check**: Verifies current VMs in development environment
    2. **Git Repository Setup**: Navigates to the Apps repository and ensures correct branch
    3. **VM Definition Creation**: Creates a new VM definition file (`vm-web-09.yaml`) based on existing templates
    4. **Kustomization Update**: Updates the kustomization.yaml to include the new VM
    5. **Git Workflow**: Commits and pushes changes to the development branch
    6. **ArgoCD Sync**: Monitors ArgoCD for manual sync and deployment
    7. **Deployment Verification**: Confirms the new VM is created and operational
    8. **Cleanup**: Provides option to remove the VM for demo repeatability
    
    ## Environment Details
    - **GUID**: Dynamic based on environment variable
    - **Namespace**: `workshop-gitops-vms-dev`
    - **New VM Name**: `dev-vm-web-09`
    - **ArgoCD Application**: `workshop-gitops-vms-dev`
    - **Git Repository**: `OpenShift-Virtualization-GitOps-Apps`
    -- **Target Branch**: `vms-dev-GUID` (GUID-specific development branch)
    
    ## Step-by-Step Manual Instructions
    
    ### Step 1: Check Current State
    
    1. Check current ArgoCD application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    2. List existing VMs in development environment:
    ```bash
    oc get vm -n workshop-gitops-vms-dev | grep -E "(NAME|dev-vm-web)"
    ```
    
    3. Verify the new VM doesn't exist yet:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: Should show only existing VMs (typically vm-web-01, vm-web-02, vm-web-03), and dev-vm-web-09 should not exist
    
    ### Step 2: Navigate to Git Repository
    
    1. Change to your Git repository directory:
    ```bash
    cd /opt/OpenShift-Virtualization-GitOps-Apps
    ```
    
    2. Ensure you're on the correct branch:
    ```bash
    git branch --show-current
    ```
    
    3. Switch to vms-dev-GUID branch if needed:
    ```bash
    git checkout vms-dev-$GUID
    ```
    
    4. Pull latest changes:
    ```bash
    git pull origin vms-dev-$GUID
    ```
    
    **Expected Result**: You should be on the `vms-dev-$GUID` branch with latest changes
    
    ### Step 3: Create New VM Definition
    
    1. Create the new VM file `base/vm-web-09.yaml`:
    ```bash
    cat > base/vm-web-09.yaml << 'EOF'
    apiVersion: kubevirt.io/v1
    kind: VirtualMachine
    metadata:
      name: vm-web-09
      labels:
        app: web-server
        workshop: gitops-ocpvirt
      annotations:
        workshop.gitops/config-version: "v4-fedora-firewall-fix"
    spec:
      dataVolumeTemplates:
      - apiVersion: cdi.kubevirt.io/v1beta1
        kind: DataVolumeTemplate
        metadata:
          name: vm-web-09
        spec:
          sourceRef:
            kind: DataSource
            name: fedora
            namespace: openshift-virtualization-os-images
          storage:
            resources:
              requests:
                storage: 30Gi
      running: true
      template:
        metadata:
          labels:
            kubevirt.io/size: small
            kubevirt.io/domain: vm-web-09
            app: web-server
        spec:
          domain:
            cpu:
              cores: 1
              sockets: 1
              threads: 1
            devices:
              disks:
              - disk:
                  bus: virtio
                name: rootdisk
              - disk:
                  bus: virtio
                name: cloudinitdisk
              interfaces:
              - masquerade: {}
                name: default
              networkInterfaceMultiqueue: true
              rng: {}
            machine:
              type: pc-q35-rhel8.6.0
            resources:
              requests:
                memory: 2Gi
          evictionStrategy: LiveMigrate
          networks:
          - name: default
            pod: {}
          terminationGracePeriodSeconds: 180
          volumes:
          - dataVolume:
              name: vm-web-09
            name: rootdisk
          - cloudInitNoCloud:
              userData: |
                #cloud-config
                user: cloud-user
                password: redhat123
                chpasswd: { expire: False }
                packages:
                  - httpd
                  - firewalld
                runcmd:
                  - systemctl enable httpd
                  - systemctl start httpd
                  - echo 'Web Server - VM 09' > /var/www/html/index.html
                  - systemctl enable firewalld
                  - systemctl start firewalld
                  - firewall-cmd --permanent --add-service=http || true
                  - firewall-cmd --reload || true
            name: cloudinitdisk
          accessCredentials:
          - sshPublicKey:
              source:
                secret:
                  secretName: workshop-ssh-public-key
              propagationMethod:
                noCloud: {}
    EOF
    ```
    
    2. Verify the file was created:
    ```bash
    ls -la base/vm-web-09.yaml
    cat base/vm-web-09.yaml | head -20
    ```
    
    **Expected Result**: File should be created with VM definition
    
    ### Step 4: Update Kustomization to Include New VM
    
    1. Update the `base/kustomization.yaml` file:
    ```bash
    cat > base/kustomization.yaml << 'EOF'
    apiVersion: kustomize.config.k8s.io/v1beta1
    kind: Kustomization
    
    resources:
      - vm-web-09.yaml
      - vm-web-01.yaml
      - vm-web-02.yaml
      - vm-web-service.yaml
    EOF
    ```
    
    2. Verify the updated kustomization:
    ```bash
    cat base/kustomization.yaml
    ```
    
    **Expected Result**: Kustomization should include vm-web-09.yaml in the resources list
    
    ### Step 5: Commit and Push Changes to Git
    
    1. Check Git status:
    ```bash
    git status
    ```
    
    2. Add the new files:
    ```bash
    git add .
    ```
    
    3. Commit the changes:
    ```bash
    git commit -m "feat: add development VM web-09 for expanded testing environment
    
    - Add vm-web-09.yaml with Fedora-based web server configuration
    - Update base kustomization to include new VM resource
    - Provides additional development capacity for testing scenarios"
    ```
    
    4. Push changes to repository:
    ```bash
    git push origin vms-dev-$GUID
    ```
    
    5. Verify push was successful:
    ```bash
    git log --oneline -1
    ```
    
    **Expected Result**: Changes should be committed and pushed to the vms-dev-GUID branch
    
    ### Step 6: Return to OpenShift and Monitor ArgoCD
    
    1. Return to your original working directory:
    ```bash
    cd -
    ```
    
    2. Force ArgoCD to check for changes:
    ```bash
    oc patch applications workshop-gitops-vms-dev -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}'
    ```
    
    3. Monitor application status until drift is detected:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}' ; echo
    ```
    
    **Expected Result**: Application status should change to "OutOfSync"
    
    ### Step 7: Trigger ArgoCD Sync
    
    1. Trigger manual sync:
    ```bash
    oc patch applications workshop-gitops-vms-dev -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}'
    ```
    
    2. Monitor sync progress:
    ```bash
    watch oc get applications workshop-gitops-vms-dev -n openshift-gitops -o jsonpath='{.status.sync.status}'
    ```
    
    **Expected Result**: Sync should be initiated
    
    ### Step 8: Monitor New VM Creation
    
    1. Watch for new VM creation:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev
    ```
    
    2. Monitor VM status during creation:
    ```bash
    watch oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o custom-columns="NAME:.metadata.name,STATUS:.status.printableStatus"
    ```
    
    3. Check DataVolume creation:
    ```bash
    oc get dv -n workshop-gitops-vms-dev | grep vm-web-09
    ```
    
    **Expected Result**: New VM should be created and begin provisioning
    
    ### Step 9: Wait for Application Sync Completion
    
    1. Monitor until application returns to Synced state:
    ```bash
    watch oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    **Expected Result**: Application should return to "Synced" status
    
    ### Step 10: Verify New VM Deployment
    
    1. Check that the new VM exists and is properly configured:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o custom-columns="NAME:.metadata.name,STATUS:.status.printableStatus,MEMORY:.spec.template.spec.domain.resources.requests.memory"
    ```
    
    2. Verify VM configuration:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o jsonpath='{.spec.running}' ; echo
    ```
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o jsonpath='{.spec.template.spec.domain.cpu.cores}' ; echo
    ```
    
    3. List all VMs in development environment:
    ```bash
    oc get vm -n workshop-gitops-vms-dev | grep -E "(NAME|dev-vm-web)"
    ```
    
    4. Check if VM is running (may take time to start):
    ```bash
    oc get vmi dev-vm-web-09 -n workshop-gitops-vms-dev
    ```
    
    **Expected Result**: 
    - New VM should exist with correct configuration
    - Development environment should now have 4 VMs
    - VM should eventually start running
    
    ### Step 11: Final Verification
    
    1. Verify final application status:
    ```bash
    oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status"
    ```
    
    2. Count total VMs in environment:
    ```bash
    oc get vm -n workshop-gitops-vms-dev --no-headers | wc -l
    ```
    
    3. Check VM labels and annotations:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o jsonpath='{.metadata.labels}' ; echo
    ```
    
    **Expected Result**: Environment should have expanded from 3 to 4 VMs, all managed by GitOps
    
    ## Summary of What Was Demonstrated
    
    ✓ **Infrastructure as Code**: New VM defined in Git repository  
    ✓ **Kustomization Update**: Base configuration updated to include new resource  
    ✓ **Git Workflow**: Changes committed and pushed through proper Git workflow  
    ✓ **Manual Detection**: ArgoCD detected Git changes after manual sync  
    ✓ **Controlled Deployment**: New VM deployed through manual sync operations  
    ✓ **Environment Expansion**: Development environment scaled from 3 to 4 VMs  
    ✓ **Configuration Consistency**: New VM follows same patterns as existing VMs  
    
    ## Key Learning Points
    
    - **Scalability**: Easy to add new infrastructure through Git changes
    - **Consistency**: New resources follow established patterns and configurations
    - **Audit Trail**: All infrastructure changes tracked in Git history
    - **Collaboration**: Multiple team members can propose infrastructure changes via Git
    - **Rollback Capability**: Changes can be easily reverted through Git
    - **Environment Parity**: Same process works across dev/test/prod environments
    
    ## Use Cases
    
    This pattern is valuable for:
    - **Environment Scaling**: Adding capacity during peak periods
    - **Development**: Creating isolated development VMs for features
    - **Testing**: Provisioning test environments for specific scenarios
    - **Disaster Recovery**: Quickly recreating lost infrastructure
    
    ## Cleanup (Optional)
    
    To remove the new VM after the demo:
    
    1. Remove from kustomization:
    ```bash
    cd /opt/OpenShift-Virtualization-GitOps-Apps
    ```
    
    2. Delete the VM file:
    ```bash
    rm base/vm-web-09.yaml
    ```
    
    3. Commit and push:
    ```bash
    git add -A
    ```
    ```bash
    git commit -m "cleanup: remove demo VM web-09"
    ```
    ```bash
    git push origin vms-dev-$GUID
    ```

  04-DEMO4-MULTI-ENV-MANAGEMENT.md: |
    # Demo 4: Multi-Environment VM Management with Kustomize
    
    ## Overview
    This demo demonstrates advanced GitOps practices for managing Virtual Machines across multiple environments (development, homologation, and production) using Kustomize overlays and Git branch promotion strategies. It showcases how to efficiently manage environment-specific configurations while maintaining consistency across environments through manual sync operations. The demo is automated through Ansible playbooks but includes manual step-by-step instructions for educational purposes.
    
    ## Prerequisites
    - OpenShift GitOps Workshop installed and configured
    - GUID environment variable set (`export GUID=user01`)
    - Workshop GitOps VMs deployed in all environments (dev, hml, prd)
    - Access to Git repository: `OpenShift-Virtualization-GitOps-Apps`
    - Git configured for commits and push access to the repository
    - Demo 3 completed (dev-vm-web-09 exists in development environment)
    
    ## What the Demo Does
    
    1. **Environment Status Check**: Verifies all ArgoCD applications and current VMs in each environment
    2. **Development to Homologation Promotion**: 
       - Merges development branch changes into homologation branch
       - Updates Kustomize overlays for environment-specific configurations
       - Monitors ArgoCD sync for homologation environment
    3. **Homologation to Production Promotion**:
       - Merges homologation branch changes into production branch
       - Applies production-specific Kustomize patches
       - Monitors ArgoCD sync for production environment
    4. **Verification**: Confirms VMs are deployed in all environments with correct configurations
    5. **Environment Comparison**: Shows differences in VM configurations across environments (CPU, memory, naming)
    
    ## Environment Details
    - **GUID**: Dynamic based on environment variable
    - **Development Namespace**: `workshop-gitops-vms-dev`
    - **Homologation Namespace**: `workshop-gitops-vms-hml`
    - **Production Namespace**: `workshop-gitops-vms-prd`
    - **ArgoCD Applications**: 
      - `workshop-gitops-vms-dev` (targets `vms-dev-GUID` branch)
      - `workshop-gitops-vms-hml` (targets `vms-hml-GUID` branch)
      - `workshop-gitops-vms-prd` (targets `vms-prd-GUID` branch)
    - **Git Repository**: `OpenShift-Virtualization-GitOps-Apps`
    
    ## Kustomize Environment Strategy
    
    The demo showcases how Kustomize overlays provide environment-specific configurations:
    
    - **Development**: Lower resource allocation, development naming prefix
    - **Homologation**: Medium resource allocation, homologation naming prefix  
    - **Production**: Higher resource allocation, production naming prefix, enhanced monitoring
    
    ## Step-by-Step Manual Instructions
    
    ### Step 1: Verify Current State
    
    1. Check all ArgoCD applications status:
    ```bash
    oc get applications -n openshift-gitops | grep workshop-gitops-vms
    ```
    
    2. List VMs in all environments to confirm current state:
    ```bash
    echo "=== Development Environment ==="
    oc get vm -n workshop-gitops-vms-dev | grep -E "(NAME|vm-web)"
    
    echo "=== Homologation Environment ==="
    oc get vm -n workshop-gitops-vms-hml | grep -E "(NAME|vm-web)"
    
    echo "=== Production Environment ==="
    oc get vm -n workshop-gitops-vms-prd | grep -E "(NAME|vm-web)"
    ```
    
    3. Verify that dev-vm-web-09 exists only in development:
    ```bash
    echo "Checking dev-vm-web-09 in development:"
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev --no-headers 2>/dev/null || echo "Not found"
    
    echo "Checking hml-vm-web-09 in homologation:"
    oc get vm hml-vm-web-09 -n workshop-gitops-vms-hml --no-headers 2>/dev/null || echo "Not found (expected)"
    
    echo "Checking prd-vm-web-09 in production:"
    oc get vm prd-vm-web-09 -n workshop-gitops-vms-prd --no-headers 2>/dev/null || echo "Not found (expected)"
    ```
    
    **Expected Result**: dev-vm-web-09 should exist only in development environment
    
    ### Step 2: Navigate to Git Repository and Check Branches
    
    1. Change to your Git repository directory:
    ```bash
    cd /opt/OpenShift-Virtualization-GitOps-Apps
    ```
    
    2. Check current branch and available branches:
    ```bash
    git branch -a
    git status
    ```
    
    3. Ensure you're on the vms-dev-GUID branch:
    ```bash
    git checkout vms-dev-$GUID
    ```
    
    **Expected Result**: You should be on vms-dev-GUID branch with no uncommitted changes
    
    ### Step 3: Promote Development Changes to Homologation
    
    1. Create a merge to homologation branch:
    ```bash
    git checkout vms-hml-$GUID
    git merge vms-dev-$GUID
    ```
    
    2. Push the changes:
    ```bash
    git push origin vms-hml-$GUID
    ```
    
    3. Force ArgoCD to detect and sync the changes:
    ```bash
    oc patch applications workshop-gitops-vms-hml -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}' &>/dev/null
    ```
    
    4. Verify the VM was created in homologation:
    ```bash
    oc get vm -n workshop-gitops-vms-hml | grep hml-vm-web-09
    ```
    
    **Expected Result**: hml-vm-web-09 should be created in the homologation environment
    
    ### Step 4: Promote Homologation Changes to Production
    
    1. Merge homologation to main (production):
    ```bash
    git checkout vms-prd-$GUID
    git merge vms-hml-$GUID
    ```
    
    2. Push the changes:
    ```bash
    git push origin vms-prd-$GUID
    ```
    
    3. Force ArgoCD to detect and sync the changes:
    ```bash
    oc patch applications workshop-gitops-vms-prd -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}' &>/dev/null
    ```
    
    4. Verify the VM was created in production:
    ```bash
    oc get vm -n workshop-gitops-vms-prd | grep prd-vm-web-09
    ```
    
    **Expected Result**: prd-vm-web-09 should be created in the production environment
    
    ### Step 5: Verify Multi-Environment Deployment
    
    1. List all vm-web-09 instances across environments:
    ```bash
    echo "=== VM Web 09 Across All Environments ==="
    echo "Development:"
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev --no-headers 2>/dev/null || echo "Not found"
    
    echo "Homologation:"
    oc get vm hml-vm-web-09 -n workshop-gitops-vms-hml --no-headers 2>/dev/null || echo "Not found"
    
    echo "Production:"
    oc get vm prd-vm-web-09 -n workshop-gitops-vms-prd --no-headers 2>/dev/null || echo "Not found"
    ```
    
    2. Compare configurations between environments using Kustomize:
    ```bash
    echo "=== Development Configuration ==="
    oc kustomize overlays/dev | grep -A 5 -B 5 "vm-web-09"
    
    echo "=== Homologation Configuration ==="
    oc kustomize overlays/hml | grep -A 5 -B 5 "vm-web-09"
    
    echo "=== Production Configuration ==="
    oc kustomize overlays/prd | grep -A 5 -B 5 "vm-web-09"
    ```
    
    **Expected Result**: All three environments should have their respective VM instances with proper naming prefixes and namespace configurations
    
    ### Step 6: Demonstrate Centralized Base Management
    
    1. Go back to development branch to make a base change:
    ```bash
    git checkout vms-dev-$GUID
    ```
    
    2. Add a new annotation to the base VM template:
    ```bash
    # Edit the base vm-web-09.yaml file to add a new annotation
    sed -i '/workshop.gitops\/config-version/a\    workshop.gitops/demo4-timestamp: "'$(date +%Y%m%d-%H%M%S)'"' base/vm-web-09.yaml
    ```
    
    3. Commit the change:
    ```bash
    git add base/vm-web-09.yaml
    git commit -m "Add demo4 timestamp annotation to vm-web-09 base template"
    git push origin vms-dev-$GUID
    ```
    
    4. Force ArgoCD to detect and sync the changes:
    ```bash
    oc patch applications workshop-gitops-vms-dev -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}'
    ```
    
    5. Wait for development environment to sync:
    ```bash
    echo "Waiting for development environment to sync..."
    watch -n 5 "oc get applications workshop-gitops-vms-dev -n openshift-gitops -o custom-columns='NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status'"
    ```
    
    6. Verify the annotation was added in development:
    ```bash
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o yaml | grep -A 3 -B 3 "demo4-timestamp"
    ```
    
    **Expected Result**: The new annotation should appear in the development VM
    
    ### Step 7: Promote Base Changes Through All Environments
    
    1. Promote the base change to homologation:
    ```bash
    git checkout vms-hml-$GUID
    git merge vms-dev-$GUID
    git push origin vms-hml-$GUID
    ```
    
    2. Force ArgoCD to detect and sync the changes in homologation:
    ```bash
    oc patch applications workshop-gitops-vms-hml -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}' &>/dev/null
    ```
    
    3. Promote to production:
    ```bash
    git checkout vms-prd-$GUID
    git merge vms-hml-$GUID
    git push origin vms-prd-$GUID
    ```
    
    4. Force ArgoCD to detect and sync the changes in production:
    ```bash
    oc patch applications workshop-gitops-vms-prd -n openshift-gitops --type merge -p '{"operation":{"sync":{"syncStrategy":{"hook":{}}}}}' &>/dev/null
    ```
    
    5. Wait for all environments to sync and verify the annotation exists in all VMs:
    ```bash
    echo "=== Checking annotations across all environments ==="
    echo "Development:"
    oc get vm dev-vm-web-09 -n workshop-gitops-vms-dev -o yaml | grep "demo4-timestamp" || echo "Not found"
    
    echo "Homologation:"
    oc get vm hml-vm-web-09 -n workshop-gitops-vms-hml -o yaml | grep "demo4-timestamp" || echo "Not found"
    
    echo "Production:"
    oc get vm prd-vm-web-09 -n workshop-gitops-vms-prd -o yaml | grep "demo4-timestamp" || echo "Not found"
    ```
    
    **Expected Result**: The same annotation should appear in all three environments, demonstrating how base template changes propagate through the promotion pipeline
    
    ### Step 8: Demonstrate Environment-Specific Differences
    
    1. Show how Kustomize handles environment-specific configurations:
    ```bash
    echo "=== Resource Names Across Environments ==="
    oc get vm -n workshop-gitops-vms-dev | grep vm-web-09
    oc get vm -n workshop-gitops-vms-hml | grep vm-web-09  
    oc get vm -n workshop-gitops-vms-prd | grep vm-web-09
    
    echo "=== Services Across Environments ==="
    oc get svc -n workshop-gitops-vms-dev | grep vm-web-service
    oc get svc -n workshop-gitops-vms-hml | grep vm-web-service
    oc get svc -n workshop-gitops-vms-prd | grep vm-web-service
    
    echo "=== Routes Across Environments ==="
    oc get route -n workshop-gitops-vms-dev | grep vm-web-route
    oc get route -n workshop-gitops-vms-hml | grep vm-web-route
    oc get route -n workshop-gitops-vms-prd | grep vm-web-route
    ```
    
    **Expected Result**: Each environment should have appropriately prefixed resources (dev-, hml-, prd-) in their respective namespaces
    
    ## Demo Summary
    
    This demo demonstrates several key GitOps and Kustomize concepts:
    
    1. **Branch-based Environment Promotion**: Changes flow from `vms-dev` → `vms-hml` → `main` (production)
    2. **Kustomize Overlays**: Environment-specific configurations without code duplication
    3. **Centralized Base Management**: Common changes applied once in base templates manually propagate to all environments
    4. **Consistent Multi-Environment Deployment**: Same base configuration with environment-specific customizations
    5. **GitOps Control**: ArgoCD detects and applies changes across all environments through manual sync operations
    
    ## Key Learning Points
    
    - **DRY Principle**: Don't Repeat Yourself - manage common configurations in base templates
    - **Safe Promotion**: Use Git branches to control promotion flow between environments
    - **Environment Isolation**: Each environment maintains its own namespace and configurations
    - **Manual Synchronization**: ArgoCD ensures environments stay in sync with their respective Git branches through manual sync operations
    - **Configuration Management**: Kustomize provides a declarative way to manage environment differences
    
    ### Verification Commands
    
    ```bash
    # Check all ArgoCD applications
    oc get applications -n openshift-gitops
    
    # Check VM status across environments
    for ns in workshop-gitops-vms-dev workshop-gitops-vms-hml workshop-gitops-vms-prd; do
      echo "=== Namespace: $ns ==="
      oc get vm -n $ns | grep vm-web-09
    done
    
    # Check Git branch status
    cd /opt/OpenShift-Virtualization-GitOps-Apps
    git log --oneline --graph --branches
    ```
    
    ## Cleanup
    
    To clean up the resources created in this demo:
    
    ```bash
    # Remove vm-web-09 from all branches (optional)
    cd /opt/OpenShift-Virtualization-GitOps-Apps
    
    # Remove from development
    git checkout vms-dev-$GUID
    git rm base/vm-web-09.yaml
    sed -i '/vm-web-09.yaml/d' base/kustomization.yaml
    git commit -m "Remove vm-web-09 from development"
    git push origin vms-dev-$GUID
    
    # Promote removal through environments
    git checkout vms-hml-$GUID
    git merge vms-dev-$GUID -m "Remove vm-web-09 from homologation"
    git push origin vms-hml-$GUID
    
    git checkout vms-prd-$GUID
    git merge vms-hml-$GUID -m "Remove vm-web-09 from production"
    git push origin vms-prd-$GUID
    ```
    
    Wait for ArgoCD to sync and remove the VMs from all environments through manual sync operations.

